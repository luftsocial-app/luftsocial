import { Injectable, NotFoundException, BadRequestException } from '@nestjs/common';
import { OrganizationWebhookEvent, UserWebhookEvent } from '@clerk/express';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { PinoLogger } from 'nestjs-pino';
import { Tenant } from './entities/tenant.entity';

@Injectable()
export class TenantService {
  private tenantId: string;

  constructor(
    @InjectRepository(Tenant) private readonly tenantRepo: Repository<Tenant>,
    private readonly logger: PinoLogger,
  ) {
    this.logger.setContext(TenantService.name);
  }

  setTenantId(id: string) {
    this.tenantId = id;
  }

  getTenantId(): string {
    this.logger.info({ tenantId: this.tenantId });

    return this.tenantId;
  }

  async createTenant(createOrgData: OrganizationWebhookEvent): Promise<void> {
    const tenant = this.tenantRepo.create({
      id: createOrgData.data.id,
      name: createOrgData.data['name'],
      slug: createOrgData.data['slug'],
      createdAt: new Date(createOrgData.data['created_at']),
    });

    await this.tenantRepo.save(tenant);
  }

  async updateTenant(updateOrgData: OrganizationWebhookEvent): Promise<void> {
    const tenant = await this.tenantRepo.findOne({
      where: { id: updateOrgData.data.id },
    });

    // create a new tenant if it doesn't exist
    if (!tenant) {
      this.logger.info('Tenant not found, creating a new one');
      this.createTenant(updateOrgData);
      return;
    }

    tenant.name = updateOrgData.data['name'];
    tenant.slug = updateOrgData.data['slug'];
    tenant.updatedAt = new Date(updateOrgData.data['updated_at']);
    await this.tenantRepo.save(tenant);
  }

  async deleteTenant(deleteOrgData: OrganizationWebhookEvent): Promise<void> {
    const tenant = await this.tenantRepo.findOne({
      where: { id: deleteOrgData.data.id },
    });

    if (!tenant) {
      throw new NotFoundException('Tenant not found');
    }

    await this.tenantRepo.delete(tenant.id);
  }

  async createPersonalTenant(
    userEventData: UserWebhookEvent['data'],
  ): Promise<Tenant> {
    this.logger.info(
      { userId: userEventData.id },
      'Creating personal tenant for user',
    );
    let tenantName = 'Personal Workspace'; // Default name
    if (userEventData.first_name) {
      tenantName = `${userEventData.first_name}'s Workspace`;
    } else if (userEventData.last_name) {
      tenantName = `${userEventData.last_name}'s Workspace`;
    } else if (userEventData.username) {
      tenantName = `${userEventData.username}'s Workspace`;
    }

    // Ensure tenantName is not excessively long
    if (tenantName.length > 255) {
      tenantName = tenantName.substring(0, 252) + '...';
    }

    // Generate a slug (basic version, consider a more robust slugification library if needed)
    let slug = tenantName
      .toLowerCase()
      .replace(/\s+/g, '-')
      .replace(/[^a-z0-9-]/g, '');

    if (slug.length > 255) {
      slug = slug.substring(0, 255);
    }
    // Ensure slug is unique (this is a simplified check, a real implementation might need a loop and DB check)
    const existingTenantWithSlug = await this.tenantRepo.findOne({ where: { slug } });
    if (existingTenantWithSlug) {
        slug = `${slug}-${Date.now()}`; // Append timestamp to ensure uniqueness
        if (slug.length > 255) {
            slug = slug.substring(0, 255);
        }
    }


    const newTenant = this.tenantRepo.create({
      name: tenantName,
      slug: slug,
      // Set other default properties for a personal tenant as needed
      // For example, maxUsers: 1, or specific feature flags.
      // For now, we'll rely on database defaults or nullable fields.
      // id will be auto-generated by the database (UUID)
    });

    try {
      const savedTenant = await this.tenantRepo.save(newTenant);
      this.logger.info(
        { tenantId: savedTenant.id, userId: userEventData.id },
        'Personal tenant created successfully',
      );
      return savedTenant;
    } catch (error) {
      this.logger.error(
        { error, userId: userEventData.id },
        'Error creating personal tenant',
      );
      throw new BadRequestException('Could not create personal tenant.');
    }
  }
}
